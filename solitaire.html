<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Solitaire ì™„ì„±í˜• + íŒíŠ¸ + ìë™ì™„ì„± + ëª¨ë°”ì¼ + ì• ë‹ˆë©”ì´ì…˜</title>
<style>
  :root {
    --bg: #006400;
    --card-bg: white;
    --card-text: black;
    --border: white;
    --highlight: gold;
  }
  body.dark {
    --bg: #1e1e1e;
    --card-bg: #333;
    --card-text: white;
    --border: #888;
    --highlight: orange;
  }
  body {
    margin: 0;
    font-family: sans-serif;
    background: var(--bg);
    color: white;
    transition: 0.3s;
    user-select: none;
  }
  h1 {
    text-align: center;
    padding: 10px;
  }
  #back-link {
    text-align: center;
    margin-bottom: 10px;
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin-bottom: 10px;
    color: white;
    align-items: center;
  }
  button, select {
    padding: 6px 12px;
    font-size: 14px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    background: var(--card-bg);
    color: var(--card-text);
    transition: background-color 0.2s ease;
  }
  button:hover, select:hover {
    background: var(--highlight);
    color: black;
  }
  #game {
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 600px;
    margin: auto;
  }
  .row {
    display: flex;
    gap: 8px;
    margin: 6px 0;
    flex-wrap: nowrap;
    justify-content: center;
  }
  .pile {
    width: 80px;
    height: 120px;
    border: 2px dashed var(--border);
    position: relative;
    background: transparent;
    border-radius: 5px;
    flex-shrink: 0;
  }
  .foundation {
    border: 2px solid var(--highlight);
  }
  .card {
    width: 80px;
    height: 120px;
    background: var(--card-bg);
    color: var(--card-text);
    font-family: var(--card-font, Arial);
    border-radius: 5px;
    border: 1px solid black;
    position: absolute;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    font-weight: bold;
    cursor: grab;
    user-select: none;
    box-sizing: border-box;
    z-index: 0;
    transition: top 0.3s ease, left 0.3s ease, transform 0.4s ease;
    backface-visibility: hidden;
    transform-style: preserve-3d;
  }
  .card.red {
    color: red;
  }
  .card.back {
    background: blue;
    color: transparent;
    cursor: pointer;
    border: 1px solid #0000aa;
    box-shadow: inset 0 0 15px #000099;
    transform: rotateY(0deg);
  }
  .card.flipping {
    animation: flipcard 0.6s forwards;
  }
  @keyframes flipcard {
    0%   { transform: rotateY(0deg); }
    50%  { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
  }
  .hint {
    box-shadow: 0 0 10px 3px var(--highlight);
    z-index: 9999 !important;
  }
  #ai-msg, #message, #ranking {
    text-align: center;
    margin: 6px;
    font-weight: bold;
  }
  /* ëª¨ë°”ì¼ ëŒ€ì‘ */
  @media (max-width: 700px) {
    #game {
      max-width: 100vw;
      padding: 0 5px;
    }
    .pile {
      width: 60px;
      height: 90px;
    }
    .card {
      width: 60px;
      height: 90px;
      font-size: 16px;
    }
    .row {
      gap: 6px;
    }
  }
</style>
</head>
<body>
<h1>Solitaire</h1>
<div id="back-link">
  <a href="index.html" style="color: white;">ë’¤ë¡œ ê°€ê¸°</a>
</div>
<div id="controls">
  <button onClick="startGame()">ğŸ” ìƒˆ ê²Œì„</button>
  <button onClick="undoMove()">â†© ë˜ëŒë¦¬ê¸°</button>
  <button onClick="toggleTheme()">ğŸŒ™ í…Œë§ˆ</button>
  <button id="hint-btn" onClick="showHint()">ğŸ’¡ íŒíŠ¸</button>
  <button onClick="autoComplete()">âš¡ ìë™ ì™„ì„±</button>
  <select onChange="changeCardStyle(this.value)">
    <option disabled selected>ğŸ¨ ì¹´ë“œ ìŠ¤íƒ€ì¼</option>
    <option value="Arial">Arial</option>
    <option value="Georgia">Georgia</option>
    <option value="Comic Sans MS">Comic Sans</option>
    <option value="Courier New">Courier</option>
  </select>
  <button onClick="saveGame()">ğŸ’¾ ì €ì¥</button>
  <button onClick="loadGame()">ğŸ“ ë¶ˆëŸ¬ì˜¤ê¸°</button>
  <span style="margin-left: 20px;">ì ìˆ˜: <span id="score">0</span></span>
  <span style="margin-left: 20px;">ì´ë™ ìˆ˜: <span id="moveCount">0</span></span>
</div>
<div id="game">
  <div class="row" id="top">
    <div class="pile" id="stock" onClick="drawCard()"></div>
    <div class="pile" id="waste"></div>
    <div class="pile foundation" id="f0"></div>
    <div class="pile foundation" id="f1"></div>
    <div class="pile foundation" id="f2"></div>
    <div class="pile foundation" id="f3"></div>
  </div>
  <div class="row" id="tableau"></div>
</div>
<div id="ai-msg"></div>

<script>
const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

let piles = {
  stock: [],
  waste: [],
  foundation: [[],[],[],[]],
  tableau: [[],[],[],[],[],[],[]]
};

let score = 0;
let moveHistory = [];

function isRed(suit) {
  return suit === 'â™¥' || suit === 'â™¦';
}

function createDeck() {
  let deck = [];
  for(let suit of suits) {
    for(let value of values) {
      deck.push({suit, value, faceUp:false});
    }
  }
  return deck;
}

function shuffleDeck(deck) {
  for(let i=deck.length-1; i>0; i--) {
    let j = Math.floor(Math.random()*(i+1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
}

function createCardElement(card, pileType, pileIndex, cardIndex) {
  const div = document.createElement('div');
  div.className = 'card';
  if (!card.faceUp) {
    div.classList.add('back');
    div.style.transform = 'rotateY(0deg)';
  } else {
    div.style.transform = 'rotateY(0deg)';
  }
  if (card.faceUp && isRed(card.suit)) {
    div.classList.add('red');
  }
  div.textContent = card.faceUp ? card.value + card.suit : '';
  div.style.top = (pileType === 'tableau' ? cardIndex * 25 : 0) + 'px';
  div.dataset.suit = card.suit;
  div.dataset.value = card.value;
  div.dataset.pileType = pileType;
  div.dataset.pileIndex = pileIndex;
  div.dataset.cardIndex = cardIndex;
  if (card.faceUp) {
    div.draggable = true;
    div.addEventListener('dragstart', dragStart);
    div.addEventListener('dblclick', autoMoveToFoundation);
  } else {
    div.addEventListener('click', () => flipCard(pileType, pileIndex, cardIndex));
  }
  div.style.zIndex = cardIndex + 1;
  return div;
}

function renderGame() {
  const stockEl = document.getElementById('stock');
  const wasteEl = document.getElementById('waste');
  const tableauEl = document.getElementById('tableau');
  const foundationEls = [0,1,2,3].map(i => document.getElementById('f'+i));

  stockEl.innerHTML = '';
  wasteEl.innerHTML = '';
  tableauEl.innerHTML = '';
  foundationEls.forEach(f => f.innerHTML = '');

  // Stock: í•œ ì¥ë§Œ ë³´ì´ê¸° (ë§¨ ë’¤ ì¹´ë“œ)
  if (piles.stock.length > 0) {
    const topCard = piles.stock[piles.stock.length-1];
    const cardEl = createCardElement(topCard, 'stock', 0, piles.stock.length-1);
    stockEl.appendChild(cardEl);
  }

  // Waste: ëª¨ë‘ ë³´ì—¬ì£¼ê¸° (í•œ ì¤„ì— ìŒ“ê¸°)
  piles.waste.forEach((card, idx) => {
    const cardEl = createCardElement(card, 'waste', 0, idx);
    wasteEl.appendChild(cardEl);
  });

  // Foundation
  piles.foundation.forEach((pile, idx) => {
    pile.forEach((card, idxCard) => {
      const cardEl = createCardElement(card, 'foundation', idx, idxCard);
      foundationEls[idx].appendChild(cardEl);
    });
  });

  // Tableau
  for(let i=0; i<7; i++) {
    const pileDiv = document.createElement('div');
    pileDiv.className = 'pile';
    pileDiv.dataset.pileType = 'tableau';
    pileDiv.dataset.pileIndex = i;
    pileDiv.addEventListener('dragover', allowDrop);
    pileDiv.addEventListener('drop', dropCard);

    piles.tableau[i].forEach((card, idxCard) => {
      const cardEl = createCardElement(card, 'tableau', i, idxCard);
      pileDiv.appendChild(cardEl);
    });

    tableauEl.appendChild(pileDiv);
  }

  updateScore(0); // ì ìˆ˜ ê°±ì‹ 
  updateMoveCount();
}

function flipCard(pileType, pileIndex, cardIndex) {
  let pile = piles[pileType];
  if (pileType === 'foundation' || pileType === 'stock' || pileType === 'waste') return; // ë’¤ì§‘ê¸° ì•ˆë¨
  const card = pile[pileIndex][cardIndex];
  if (!card.faceUp) {
    // ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜
    const cardsEls = document.querySelectorAll(`.card[data-pile-type="${pileType}"][data-pile-index="${pileIndex}"][data-card-index="${cardIndex}"]`);
    cardsEls.forEach(el => {
      el.classList.add('flipping');
      el.style.transform = 'rotateY(90deg)';
      setTimeout(() => {
        card.faceUp = true;
        renderGame();
      }, 300);
      setTimeout(() => {
        el.classList.remove('flipping');
        el.style.transform = 'rotateY(0deg)';
      }, 600);
    });
    updateScore(5);
  }
}

// ë“œë˜ê·¸ ì‹œì‘
function dragStart(e) {
  const cardEl = e.target;
  const pileType = cardEl.dataset.pileType;
  const pileIndex = parseInt(cardEl.dataset.pileIndex);
  const cardIndex = parseInt(cardEl.dataset.cardIndex);

  if (pileType !== 'tableau') {
    // í…Œì´ë¸” ë°– ì¹´ë“œ í•œì¥ë§Œ ì´ë™ ê°€ëŠ¥
    e.dataTransfer.setData('text/plain', JSON.stringify({pileType, pileIndex, cardIndex, count:1}));
  } else {
    // í…Œì´ë¸”ì—ì„œëŠ” ì—¬ëŸ¬ì¥ ë¬¶ìŒ ì´ë™ ê°€ëŠ¥
    const count = piles.tableau[pileIndex].length - cardIndex;
    e.dataTransfer.setData('text/plain', JSON.stringify({pileType, pileIndex, cardIndex, count}));
  }
}

// ë“œë¡­ í—ˆìš©
function allowDrop(e) {
  e.preventDefault();
}

// ì¹´ë“œ ì´ë™ ê°€ëŠ¥ ì—¬ë¶€ ê²€ì‚¬
function canMoveCards(cards, toPileType, toPileIndex) {
  if (cards.length === 0) return false;
  const first = cards[0];
  if (toPileType === 'foundation') {
    const pile = piles.foundation[toPileIndex];
    if (pile.length === 0) return first.value === 'A';
    const top = pile[pile.length-1];
    return top.suit === first.suit && values.indexOf(first.value) === values.indexOf(top.value) +1;
  } else if (toPileType === 'tableau') {
    const pile = piles.tableau[toPileIndex];
    if (pile.length === 0) return first.value === 'K';
    const top = pile[pile.length-1];
    if (!top.faceUp) return false;
    const isOppositeColor = isRed(top.suit) !== isRed(first.suit);
    const isOneLower = values.indexOf(first.value) === values.indexOf(top.value) - 1;
    return isOppositeColor && isOneLower;
  }
  return false;
}

// ì¹´ë“œ ë“œë¡­ ì‹œ ì²˜ë¦¬
function dropCard(e) {
  e.preventDefault();
  const target = e.currentTarget;
  const toPileType = target.dataset.pileType;
  const toPileIndex = parseInt(target.dataset.pileIndex);

  const data = JSON.parse(e.dataTransfer.getData('text/plain'));
  const {pileType: fromPileType, pileIndex: fromPileIndex, cardIndex: fromCardIndex, count} = data;

  let movingCards;
  if (fromPileType === 'tableau') {
    movingCards = piles.tableau[fromPileIndex].slice(fromCardIndex, fromCardIndex + count);
  } else if (fromPileType === 'waste') {
    movingCards = [piles.waste[piles.waste.length-1]];
  } else if (fromPileType === 'stock') {
    movingCards = [piles.stock[piles.stock.length-1]];
  } else {
    return; // ì´ë™ ë¶ˆê°€
  }

  if (!canMoveCards(movingCards, toPileType, toPileIndex)) return;

  // ì´ë™ ì²˜ë¦¬
  if (fromPileType === 'tableau') {
    piles.tableau[fromPileIndex].splice(fromCardIndex, count);
    // ì• ì¹´ë“œ ë’¤ì§‘ê¸°
    if (piles.tableau[fromPileIndex].length > 0) {
      let lastCard = piles.tableau[fromPileIndex][piles.tableau[fromPileIndex].length - 1];
      if (!lastCard.faceUp) {
        lastCard.faceUp = true;
        updateScore(5);
      }
    }
  } else if (fromPileType === 'waste') {
    piles.waste.pop();
  } else if (fromPileType === 'stock') {
    piles.stock.pop();
  }

  if (toPileType === 'foundation') {
    piles.foundation[toPileIndex].push(...movingCards);
  } else if (toPileType === 'tableau') {
    piles.tableau[toPileIndex].push(...movingCards);
  }

  moveHistory.push({
    from: {pileType: fromPileType, pileIndex: fromPileIndex, cardIndex: fromCardIndex},
    to: {pileType: toPileType, pileIndex: toPileIndex},
    cards: movingCards.map(c => ({...c}))
  });
  updateScore(10 * movingCards.length);
  renderGame();
  updateMoveCount();
  checkWin();
}

// ìŠ¤í†¡ì—ì„œ ì¹´ë“œ ë½‘ê¸° (stock í´ë¦­)
function drawCard() {
  if (piles.stock.length > 0) {
    const card = piles.stock.pop();
    card.faceUp = true;
    piles.waste.push(card);
    moveHistory.push({action:'draw'});
    renderGame();
    updateMoveCount();
  } else {
    // ìŠ¤í†¡ ë¦¬ì…‹ (waste -> stock)
    while(piles.waste.length > 0) {
      const card = piles.waste.pop();
      card.faceUp = false;
      piles.stock.push(card);
    }
    moveHistory.push({action:'resetStock'});
    renderGame();
    updateMoveCount();
  }
}

// ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™ (ë”ë¸”í´ë¦­ ë˜ëŠ” íŒíŠ¸ ë“±)
function autoMoveToFoundation(e) {
  const cardEl = e.currentTarget;
  const pileType = cardEl.dataset.pileType;
  if (pileType !== 'tableau' && pileType !== 'waste') return;
  const pileIndex = parseInt(cardEl.dataset.pileIndex);
  const cardIndex = parseInt(cardEl.dataset.cardIndex);
  let card;
  if (pileType === 'waste') card = piles.waste[piles.waste.length-1];
  else card = piles.tableau[pileIndex][cardIndex];

  const idx = values.indexOf(card.value);

  for (let i=0; i<4; i++) {
    const foundation = piles.foundation[i];
    if ((foundation.length === 0 && card.value === 'A') ||
      (foundation.length > 0 && foundation[foundation.length-1].suit === card.suit &&
       values.indexOf(foundation[foundation.length-1].value) === idx-1)) {
      // ì´ë™ ê°€ëŠ¥
      if (pileType === 'tableau') {
        piles.tableau[pileIndex].splice(cardIndex, 1);
        // ì• ì¹´ë“œ ë’¤ì§‘ê¸°
        if (piles.tableau[pileIndex].length > 0) {
          let lastCard = piles.tableau[pileIndex][piles.tableau[pileIndex].length -1];
          if (!lastCard.faceUp) {
            lastCard.faceUp = true;
            updateScore(5);
          }
        }
      } else if (pileType === 'waste') {
        piles.waste.pop();
      }
      piles.foundation[i].push(card);
      updateScore(50);
      moveHistory.push({
        from: {pileType, pileIndex, cardIndex},
        to: {pileType:'foundation', pileIndex:i},
        cards: [card]
      });
      renderGame();
      updateMoveCount();
      checkWin();
      return;
    }
  }
}

// ìë™ ì™„ì„± - ê°€ëŠ¥í•œ ì¹´ë“œ ëª¨ë‘ íŒŒìš´ë°ì´ì…˜ìœ¼ë¡œ ì´ë™ (ë’¤ì§‘ê¸° ì²˜ë¦¬ í¬í•¨)
function autoComplete() {
  let moved = false;
  // tableauì—ì„œ ì´ë™ ê°€ëŠ¥í•œ ì¹´ë“œ ì²´í¬
  outer:
  for(let i=0; i<7; i++) {
    for(let j=0; j<piles.tableau[i].length; j++) {
      const card = piles.tableau[i][j];
      if (!card.faceUp) continue;
      const idx = values.indexOf(card.value);
      for(let f=0; f<4; f++) {
        const foundation = piles.foundation[f];
        if ((foundation.length === 0 && card.value === 'A') ||
            (foundation.length > 0 &&
             foundation[foundation.length-1].suit === card.suit &&
             values.indexOf(foundation[foundation.length-1].value) === idx-1)) {
          piles.tableau[i].splice(j, 1);
          piles.foundation[f].push(card);
          updateScore(50);
          moveHistory.push({
            from: {pileType:'tableau', pileIndex:i, cardIndex:j},
            to: {pileType:'foundation', pileIndex:f},
            cards: [card]
          });
          // ë’¤ì§‘ê¸° ê°€ëŠ¥í•œ ì¹´ë“œ ìˆìœ¼ë©´ ë’¤ì§‘ê¸°
          if (piles.tableau[i].length > 0) {
            let lastCard = piles.tableau[i][piles.tableau[i].length-1];
            if (!lastCard.faceUp) {
              lastCard.faceUp = true;
              updateScore(5);
            }
          }
          moved = true;
          break outer;
        }
      }
    }
  }
  // wasteì—ì„œ ì´ë™ ê°€ëŠ¥í•œ ì¹´ë“œ ì²´í¬
  if (!moved && piles.waste.length > 0) {
    let card = piles.waste[piles.waste.length-1];
    const idx = values.indexOf(card.value);
    for(let f=0; f<4; f++) {
      const foundation = piles.foundation[f];
      if ((foundation.length === 0 && card.value === 'A') ||
          (foundation.length > 0 &&
           foundation[foundation.length-1].suit === card.suit &&
           values.indexOf(foundation[foundation.length-1].value) === idx-1)) {
        piles.waste.pop();
        piles.foundation[f].push(card);
        updateScore(50);
        moveHistory.push({
          from: {pileType:'waste', pileIndex:0, cardIndex:piles.waste.length},
          to: {pileType:'foundation', pileIndex:f},
          cards: [card]
        });
        moved = true;
        break;
      }
    }
  }
  if (moved) {
    renderGame();
    updateMoveCount();
    setTimeout(autoComplete, 300);
  } else {
    checkWin();
  }
}

// ì ìˆ˜ ê°±ì‹ 
function updateScore(delta) {
  if(delta !== 0) score += delta;
  document.getElementById('score').innerText = score;
}

// ì´ë™ ìˆ˜ ê°±ì‹ 
function updateMoveCount() {
  document.getElementById('moveCount').innerText = moveHistory.length;
}

// ì´ë™ ë˜ëŒë¦¬ê¸°
function undoMove() {
  if (moveHistory.length === 0) return alert('ë” ì´ìƒ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  const last = moveHistory.pop();

  if (last.action === 'draw') {
    if (piles.waste.length > 0) {
      const card = piles.waste.pop();
      card.faceUp = false;
      piles.stock.push(card);
      renderGame();
    }
  } else if (last.action === 'resetStock') {
    while(piles.stock.length > 0) {
      const card = piles.stock.pop();
      card.faceUp = true;
      piles.waste.push(card);
    }
    renderGame();
  } else if (last.cards && last.cards.length > 0) {
    const toPile = piles[last.to.pileType];
    if (last.to.pileType === 'foundation' || last.to.pileType === 'tableau') {
      toPile[last.to.pileIndex].splice(-last.cards.length, last.cards.length);
    } else if (last.to.pileType === 'waste') {
      toPile.pop();
    }

    const fromPile = piles[last.from.pileType];
    if (last.from.pileType === 'tableau') {
      fromPile[last.from.pileIndex].splice(last.from.cardIndex, 0, ...last.cards);
    } else if (last.from.pileType === 'waste') {
      fromPile.push(...last.cards);
    } else if (last.from.pileType === 'foundation') {
      fromPile[last.from.pileIndex].splice(last.from.cardIndex, 0, ...last.cards);
    }
    updateScore(-10 * last.cards.length);
    renderGame();
  }
  updateMoveCount();
}

// ìŠ¹ë¦¬ ì²´í¬
function checkWin() {
  if (piles.foundation.every(f => f.length === 13)) {
    setTimeout(() => alert('ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!'), 100);
  }
}

// ê²Œì„ ì €ì¥
function saveGame() {
  try {
    const state = JSON.stringify({piles, score, moveHistory});
    localStorage.setItem('solitaireSave', state);
    alert('ê²Œì„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
  } catch {
    alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
  }
}

// ê²Œì„ ë¶ˆëŸ¬ì˜¤ê¸°
function loadGame() {
  try {
    const stateStr = localStorage.getItem('solitaireSave');
    if (!stateStr) return alert('ì €ì¥ëœ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.');
    const state = JSON.parse(stateStr);
    piles = state.piles;
    score = state.score;
    moveHistory = state.moveHistory;
    renderGame();
    updateScore(0);
    updateMoveCount();
    alert('ê²Œì„ì´ ë¶ˆëŸ¬ì™€ì¡ŒìŠµë‹ˆë‹¤.');
  } catch {
    alert('ë¶ˆëŸ¬ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
  }
}

// í…Œë§ˆ ë³€ê²½
function toggleTheme() {
  document.body.classList.toggle('dark');
}

// ì¹´ë“œ ê¸€ê¼´ ë³€ê²½
function changeCardStyle(font) {
  document.documentElement.style.setProperty('--card-font', font);
}

// íŒíŠ¸ ê¸°ëŠ¥: ê°€ëŠ¥í•œ ì²« ì´ë™ ì°¾ì•„ì„œ ì¹´ë“œ ê°•ì¡° (3ì´ˆ í›„ ì œê±°)
function showHint() {
  clearHints();

  // 1) ë¹ˆ Foundation ìë¦¬ì— A ì¹´ë“œ ë†“ê¸° ê°€ëŠ¥í•œì§€ ì°¾ê¸°
  for (let f = 0; f < 4; f++) {
    if (piles.foundation[f].length === 0) {
      // tableauì—ì„œ A ì¹´ë“œ ì°¾ê¸°
      for (let i = 0; i < 7; i++) {
        for (let j = 0; j < piles.tableau[i].length; j++) {
          const card = piles.tableau[i][j];
          if (card.faceUp && card.value === 'A') {
            highlightCard('tableau', i, j);
            setTimeout(clearHints, 3000);
            return;
          }
        }
      }
      // wasteì—ì„œ A ì¹´ë“œ ì°¾ê¸°
      if (piles.waste.length > 0) {
        const card = piles.waste[piles.waste.length - 1];
        if (card.value === 'A') {
          highlightCard('waste', 0, piles.waste.length - 1);
          setTimeout(clearHints, 3000);
          return;
        }
      }
    }
  }

  // 2) Foundationì— ë‹¤ìŒ ì¹´ë“œ ë†“ê¸° ê°€ëŠ¥í•œì§€ ì°¾ê¸°
  for (let f = 0; f < 4; f++) {
    if (piles.foundation[f].length > 0) {
      const topCard = piles.foundation[f][piles.foundation[f].length - 1];
      const nextIndex = values.indexOf(topCard.value) + 1;
      if (nextIndex >= values.length) continue; // K ë‹¤ìŒì€ ì—†ìŒ
      const nextValue = values[nextIndex];

      // tableauì—ì„œ ë‹¤ìŒ ì¹´ë“œ ì°¾ê¸° (ê°™ì€ ë¬´ëŠ¬)
      for (let i = 0; i < 7; i++) {
        for (let j = 0; j < piles.tableau[i].length; j++) {
          const card = piles.tableau[i][j];
          if (card.faceUp && card.value === nextValue && card.suit === topCard.suit) {
            highlightCard('tableau', i, j);
            setTimeout(clearHints, 3000);
            return;
          }
        }
      }
      // wasteì—ì„œ ë‹¤ìŒ ì¹´ë“œ ì°¾ê¸°
      if (piles.waste.length > 0) {
        const card = piles.waste[piles.waste.length - 1];
        if (card.value === nextValue && card.suit === topCard.suit) {
          highlightCard('waste', 0, piles.waste.length - 1);
          setTimeout(clearHints, 3000);
          return;
        }
      }
    }
  }

  // 3) tableau ë‚´ ì´ë™ ê°€ëŠ¥í•œ ì¹´ë“œ ì°¾ê¸°
  for(let from = 0; from < 7; from++) {
    for(let cardIdx = 0; cardIdx < piles.tableau[from].length; cardIdx++) {
      const card = piles.tableau[from][cardIdx];
      if (!card.faceUp) continue;
      for(let to = 0; to < 7; to++) {
        if (to === from) continue;
        if (canMoveCards([card], 'tableau', to)) {
          highlightCard('tableau', from, cardIdx);
          setTimeout(clearHints, 3000);
          return;
        }
      }
    }
  }

  alert('ê°€ëŠ¥í•œ ì´ë™ì´ ì—†ìŠµë‹ˆë‹¤.');
}

function highlightCard(pileType, pileIndex, cardIndex) {
  const cards = document.querySelectorAll(`.card[data-pile-type="${pileType}"][data-pile-index="${pileIndex}"][data-card-index="${cardIndex}"]`);
  cards.forEach(card => card.classList.add('hint'));
}
function clearHints() {
  document.querySelectorAll('.card.hint').forEach(card => card.classList.remove('hint'));
}

// ê²Œì„ ì‹œì‘
function startGame() {
  score = 0;
  moveHistory = [];
  piles = { stock: [], waste: [], foundation: [[],[],[],[]], tableau: [[],[],[],[],[],[],[]] };

  updateScore(0);
  updateMoveCount();

  const deck = createDeck();
  shuffleDeck(deck);
  piles.stock = deck;

  // tableauì— ì¹´ë“œ ë¶„ë°° (1~7ì¥, ë§ˆì§€ë§‰ ì¹´ë“œë§Œ ì•ë©´)
  for(let i=0; i<7; i++) {
    for(let j=0; j<=i; j++) {
      let card = piles.stock.pop();
      card.faceUp = (j === i);
      piles.tableau[i].push(card);
    }
  }
  renderGame();
}

window.onload = () => startGame();

</script>
</body>
</html>
